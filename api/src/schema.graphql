scalar Point
scalar DateTime
scalar PointInput

type User {
  userId: ID!
  type: String
  fullName: String
  userName: String
  userImage: String
  email: String
  currentPosition: String
  mentoring: [User]
  goal: String
  tags: [String]
  mentors: [User]
  dataSources: [DataSource] @relationship(type: "CONNECTS_DATA", direction: IN)
  areaOfSpecialization: [Domain] @relationship(type: "IN_DOMAIN", direction: IN)
  messages: [Message] @relationship(type: "MESSAGES", direction: IN)
  posts: [Post] @relationship(type: "WRITES_POST", direction: IN)
  location: Point
  address: String
  city: String
  state: String
  country: String
  company: Company @relationship(type: "IN_COMPANY", direction: OUT)
  createdAt: DateTime
}

type Message {
  messageId: ID!
  from: User @relationship(type: "MESSAGES", direction: OUT)
  chatHistory: [MessageItem]
}

type MessageItem {
  messageItemId: ID!
  content: String
  createdAt: DateTime
  updatedAt: DateTime
}

type DataSource {
  dataSourceId: ID!
  name: String
  link: String
  user: User @relationship(type: "CONNECTS_DATA", direction: OUT)
}

type Domain {
  domainId: ID!
  name: String
  similar: [String]
  description: String
  skillSets: [SkillSet] @relationship(type: "HAS_SKILLSET", direction: IN)
  rating: Float
  experience: Float
  user: User @relationship(type: "IN_DOMAIN", direction: OUT)
}

type SkillSet {
  skillSetId: ID!
  name: String!
  type: String
  rating: Float
  experience: Float
  domain: Domain @relationship(type: "HAS_SKILLSET", direction: OUT)
}

type Post {
  postId: ID!
  content: String
  extraContent: String
  postMedia: [String]
  links: String
  likes: [User]
  user: User @relationship(type: "WRITES_POST", direction: OUT)
  comments: [Comment] @relationship(type: "HAS_COMMENT", direction: IN)
  createdAt: DateTime
  updatedAt: DateTime
}

type Comment {
  commentId: ID!
  user: User 
  content: String
  likes: [User]
  post: Post @relationship(type: "HAS_COMMENT", direction: OUT)
  createdAt: DateTime
  updatedAt: DateTime
}

type Company {
  companyId: ID!
  name: String
  city: String
  state: String
  country: String
  address: String
  location: Point
  employees: [User] @relationship(type: "IN_COMPANY", direction: IN)
}

type Business {
  businessId: ID!
  name: String!
  address: String
  city: String
  state: String
  location: Point
  avgStars: Float
    @cypher(
      statement: "MATCH (this)<-[:REVIEWS]-(r:Review) RETURN coalesce(avg(r.stars),0.0)"
    )
  reviews: [Review] @relationship(type: "REVIEWS", direction: IN)
  categories: [Category] @relationship(type: "IN_CATEGORY", direction: OUT)
}

type Review {
  reviewId: ID!
  stars: Float
  text: String
  date: DateTime
  business: Business @relationship(type: "REVIEWS", direction: OUT)
  user: User @relationship(type: "WROTE", direction: IN)
}

type Category {
  name: ID!
  businesses: [Business] @relationship(type: "IN_CATEGORY", direction: IN)
}

type RatingCount @exclude {
  stars: Float!
  count: Int!
}

type Mutation {
  mergeBusinessCategory(categories: [String!]!, businessId: ID!): Business
    @cypher(
      statement: "MATCH (b:Business {businessId: $businessId}) UNWIND $categories AS cat MERGE (c:Category {name: cat}) MERGE (b)-[:IN_CATEGORY]->(c) RETURN b"
    )
  mergeUser(name: String!, userId: ID!): User
    @cypher(
      statement: """
      MERGE (u:User {userId: $userId})
      ON CREATE SET u.name = $name
      RETURN u
      """
    )
  mergeBusiness(
    businessId: ID!
    name: String!
    address: String!
    city: String!
    state: String!
    latitude: Float!
    longitude: Float!
  ): Business
    @cypher(
      statement: """
      MERGE (b:Business {businessId: $businessId})
      ON CREATE SET b.name = $name,
                    b.address = $address,
                    b.city = $city,
                    b.state = $state,
                    b.location = Point({latitude: $latitude, longitude: $longitude})
      RETURN b
      """
    )
}

type Query {
  userCount: Int! @cypher(statement: "MATCH (u:User) RETURN COUNT(u)")
  ratingsCount: [RatingCount]
    @cypher(
      statement: "MATCH (r:Review) WITH r.stars AS stars, COUNT(*) AS count ORDER BY stars RETURN {stars: stars, count: count}"
    )
}
